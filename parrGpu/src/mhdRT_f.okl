@kernel void computeSourceTerm(
        double* S, 
        const double* U, 
        const double* xc, 
        const double* yc)
{
  int ig, jg;
  double thet; 
  double g=o_ACCEL;// 0.1;
  double su, sv; 
  double rho;
  for(int j = 0; j < o_njc; j++; @outer(0))
  {
    jg = j + o_ng;
    for(int i = 0; i < o_nic; i++; @inner(0))
    {
      ig = i + o_ng;
      thet = atan2(yc[j*o_nic+i], xc[j*o_nic+i]);
      rho = U[(jg*o_nic_g+ig)*o_NEQ+o_rhoid];
      su = -1*(rho)*(o_ACCEL)*cos(thet);
      sv = -1*(rho)*(o_ACCEL)*sin(thet);
      S[(j*o_nic+i)*o_NEQ+o_piid]= ((su*(-1)*g*cos(thet)) + (sv*(-1)*g*sin(thet)));
      S[(j*o_nic+i)*o_NEQ+o_uid] = su;
      S[(j*o_nic+i)*o_NEQ+o_vid] = sv;
      //cout << rho << " " << o_ACCEL  << endl;
    }
  }
}


@kernel void MUSCL(double* U_L, 
        double* U_R, 
        double* U_B, 
        double* U_T,
        const double* U)
{


  int ni = o_nic; //ncx
  int nj = o_njc;//ncy

  int ig, jg;
  double theta_L, theta_B, theta_R, theta_T;
  double denom_L, denom_B, denom_R, denom_T;
  double r_L, r_B, r_R, r_T;
  double ul, ull, ur, ut, ub, ubb, uc;
  double delta = 1.0e-6;
  double theta[2];
  double r[2];
  

  // loop over left and right
  for(int j = 0; j < nj; j++; @outer(0))
  {
    jg = j+o_ng;
    for(int i = 0; i <= ni; i++; @outer(0))
    {
      ig = i+o_ng;
      for(int eq = 0; eq < o_NEQ; eq++; @inner(0))
      {
        ul = U[(jg*o_nic_g+(ig-1))*o_NEQ+eq];
        ull = U[(jg*o_nic_g+(ig-2))*o_NEQ+eq];
        ur = U[(jg*o_nic_g+(ig+1))*o_NEQ+eq];
        uc = U[(jg*o_nic_g+ig)*o_NEQ+eq];

        denom_L = uc - ul;
        denom_R = ur - ul;        
        denom_L = copysign(1.0,denom_L)*fmax(delta, fabs(denom_L));    
        denom_R = copysign(1.0,denom_R)*fmax(delta, fabs(denom_R));    

        r[0] = (ul - ull)/denom_L;
        r[1] = (uc - ul)/denom_R;
        switch (o_limiter)
        {
          case 1:
            for(int id = 0; id < 2; id++)
              theta[id] = 1.0;
          case 2:
            for(int id = 0; id < 2; id++)
              theta[id] = (r[id]+fabs(r[id]))/(1.0+fabs(r[id]));
          case 3:
            for(int id = 0; id < 2; id++)
              theta[id] = (r[id]+r[id]*r[id])/(1.0+r[id]*r[id]);
          case 4:
            for(int id = 0; id < 2; id++)
              theta[id] = 1.5*(r[id]*r[id] + r[id]) / (1.0 + r[id] + r[id]*r[id]);
          case 5:
            for(int id = 0; id < 2; id++)
              theta[id] = fmax(0.0,fmin(2.0*r[id],fmin(0.5*(1.0+r[id]),2.0)));
          case 6:
            for(int id = 0; id < 2; id++)
              theta[id] = fmax(0.0,fmin(1.0,r[id]));
          case 7:
            for(int id = 0; id < 2; id++)
              theta[id] = fmax(0.0,fmax(fmin(2.0*r[id],1),fmin(r[id],2.0)));
        }

        theta_L=theta[0];
        theta_R=theta[1];

        int fill = (j*(ni+1)+i)*o_NEQ+eq;

        U_R[fill] = uc - 0.5*theta_R*(ur - uc);
        U_L[fill] = ul + 0.5*theta_L*(uc - ul);

      }
    }
  }

  // loop over bot and top
  for(int j = 0; j <= nj; j++; @outer(1))
  {
    jg = j+o_ng;
    for(int i = 0; i < ni; i++; @outer(1))
    {
      ig = i+o_ng;
      for(int eq = 0; eq < o_NEQ; eq++; @inner(1))
      {
        uc = U[(jg*o_nic_g+ig)*o_NEQ+eq];
        ub = U[((jg-1)*o_nic_g+ig)*o_NEQ+eq];
        ubb = U[((jg-2)*o_nic_g+ig)*o_NEQ+eq];
        ut = U[((jg+1)*o_nic_g+ig)*o_NEQ+eq];

        denom_B = uc - ub;
        denom_T = ut - ub;
        denom_B = copysign(1.0,denom_B)*fmax(delta, fabs(denom_B));    
        denom_T = copysign(1.0,denom_T)*fmax(delta, fabs(denom_T));    

        r[0] = (ub - ubb)/denom_B;
        r[1] = (uc - ub)/denom_T;
        switch (o_limiter)
        {
          case 1:
            for(int id = 0; id < 2; id++)
              theta[id] = 1.0;
          case 2:
            for(int id = 0; id < 2; id++)
              theta[id] = (r[id]+fabs(r[id]))/(1.0+fabs(r[id]));
          case 3:
            for(int id = 0; id < 2; id++)
              theta[id] = (r[id]+r[id]*r[id])/(1.0+r[id]*r[id]);
          case 4:
            for(int id = 0; id < 2; id++)
              theta[id] = 1.5*(r[id]*r[id] + r[id]) / (1.0 + r[id] + r[id]*r[id]);
          case 5:
            for(int id = 0; id < 2; id++)
              theta[id] = fmax(0.0,fmin(2.0*r[id],fmin(0.5*(1.0+r[id]),2.0)));
          case 6:
            for(int id = 0; id < 2; id++)
              theta[id] = fmax(0.0,fmin(1.0,r[id]));
          case 7:
            for(int id = 0; id < 2; id++)
              theta[id] = fmax(0.0,fmax(fmin(2.0*r[id],1),fmin(r[id],2.0)));
        }

        theta_B=theta[0];
        theta_T=theta[1];

        int fill = (j*ni+i)*o_NEQ+eq;

        U_B[fill] = ub + 0.5*theta_B*(uc - ub);
        U_T[fill] = uc - 0.5*theta_T*(ut - uc);

        /*
        if(eq==0){
            printf("c = %d, b = %d, t = %d, fill = %d\n", 
                (jg*o_nic_g+ig), 
                ((jg-1)*o_nic_g+ig), 
                ((jg+1)*o_nic_g+ig),(j*(ni)+i));

            printf("c = %lf, b = %lf, t = %lf, U_B=%lf, U_T=%lf\n", 
                uc, ub, ut, U_B[fill], U_T[fill]);
        }
        */
      }
    }
  }
}

@kernel void compute2dFlux(double* F, 
        double* G,  
        const double* U_L,  
        const double* U_R,  
        const double* U_B,  
        const double* U_T, 
        const double* njx, 
        const double* njy, 
        const double* nix, 
        const double* niy)
{
  int nj = o_njc;
  int ni = o_nic;
  double ul[o_NEQ], ur[o_NEQ], ub[o_NEQ], ut[o_NEQ];
  double vl[o_NEQ], vr[o_NEQ];
  double FA[o_NEQ], FB[o_NEQ];
  double FFLUX[o_NEQ];
  double GFLUX[o_NEQ];
  double rho, u, v, w, bx, by, bz, p;

  for(int j = 0; j < nj; j++; @outer(0))
  {
    for(int i = 0; i <= ni; i++; @outer(1))
    {
      int ido = j*(ni+1)+i;
      for(int eq = 0; eq < o_NEQ; eq++; @inner(0))
      {
        int id = (ido)*o_NEQ+eq;
        ul[eq] = U_L[id];
        ur[eq] = U_R[id];
      }
      
      vl[o_rhoid] = ul[o_rhoid];
      vl[o_uid] = ul[o_uid]/ul[o_rhoid];
      vl[o_vid] = ul[o_vid]/ul[o_rhoid];
      vl[o_wid] = ul[o_wid]/ul[o_rhoid];
      vl[o_piid] = ((o_gamma - 1.0) *(ul[o_piid]-( 
          - 0.5*ul[o_uid]*((ul[o_uid])/(ul[o_rhoid])) 
          - 0.5*ul[o_vid]*((ul[o_vid])/(ul[o_rhoid])) 
          - 0.5*ul[o_wid]*((ul[o_wid])/(ul[o_rhoid])) 
          - 0.5*ul[o_bxid]*(ul[o_bxid])/o_mu0
          - 0.5*ul[o_byid]*(ul[o_byid])/o_mu0
          - 0.5*ul[o_bzid]*(ul[o_bzid])/o_mu0)));
      vl[o_bxid] = ul[o_bxid];
      vl[o_byid] = ul[o_byid];
      vl[o_bzid] = ul[o_bzid];

      double ca = sqrt(ul[o_bxid]*ul[o_bxid]+ul[o_byid]*ul[o_byid]+ul[o_bzid]*ul[o_bzid]);
      double cs = sqrt(vl[o_piid]*o_gamma/ul[o_rhoid]);// p gamma/rho
      double cadir = ul[o_bxid]*ul[o_bxid]/(o_mu0*ul[o_rhoid]);
      double CA =sqrt(0.5*(ca*ca+cs*cs+sqrt((ca*ca+cs*cs)*(ca*ca+cs*cs)-4*cs*cs*cadir*cadir)));

      vr[o_rhoid] = ur[o_rhoid];
      vr[o_uid] = ur[o_uid]/ur[o_rhoid];
      vr[o_vid] = ur[o_vid]/ur[o_rhoid];
      vr[o_wid] = ur[o_wid]/ur[o_rhoid];
      vr[o_piid] = ((o_gamma - 1.0) *(ur[o_piid]-( 
          - 0.5*ur[o_uid]*((ur[o_uid])/(ur[o_rhoid])) 
          - 0.5*ur[o_vid]*((ur[o_vid])/(ur[o_rhoid])) 
          - 0.5*ur[o_wid]*((ur[o_wid])/(ur[o_rhoid])) 
          - 0.5*ur[o_bxid]*(ur[o_bxid])/o_mu0
          - 0.5*ur[o_byid]*(ur[o_byid])/o_mu0
          - 0.5*ur[o_bzid]*(ur[o_bzid])/o_mu0)));
      vr[o_bxid] = ur[o_bxid];
      vr[o_byid] = ur[o_byid];
      vr[o_bzid] = ur[o_bzid];

      ca = sqrt(ur[o_bxid]*ur[o_bxid]+ur[o_byid]*ur[o_byid]+ur[o_bzid]*ur[o_bzid]);
      cs = sqrt(vr[o_piid]*o_gamma/ur[o_rhoid]);// p gamma/rho
      cadir = ur[o_byid]*ur[o_byid]/(o_mu0*ur[o_rhoid]);
      double CB =sqrt(0.5*(ca*ca+cs*cs+sqrt((ca*ca+cs*cs)*(ca*ca+cs*cs)-4*cs*cs*cadir*cadir)));

      double u_A = (ul[o_uid]*nix[ido]+ul[o_vid]*niy[ido])/ul[o_rhoid];
      double u_B = (ur[o_uid]*nix[ido]+ur[o_vid]*niy[ido])/ur[o_rhoid];
      double b_A = (ul[o_bxid]*nix[ido]+ul[o_byid]*niy[ido])/ul[o_rhoid];
      double b_B = (ur[o_bxid]*nix[ido]+ur[o_byid]*niy[ido])/ur[o_rhoid];

      double lambdaA = fmin(u_A, u_B) - fmax(CA, CB);
      double lambdaB = fmax(u_A, u_B) + fmax(CA, CB);

      FA[o_rhoid] = vl[o_rhoid]*u_A; 

      FA[o_uid] = vl[o_rhoid]*vl[o_uid]*u_A - vl[o_bxid]*b_A/o_mu0 + vl[o_piid]*nix[ido] + (vl[o_bxid]*vl[o_bxid]+vl[o_byid]*vl[o_byid]+vl[o_bzid]*vl[o_bzid])*nix[ido]/(2*o_mu0);

      FA[o_vid] = vl[o_rhoid]*u_A*vl[o_vid]- b_A*vl[o_byid]/o_mu0 + vl[o_piid]*niy[ido] + (vl[o_bxid]*vl[o_bxid]+vl[o_byid]*vl[o_byid]+vl[o_bzid]*vl[o_bzid])*niy[ido]/(2*o_mu0);

      FA[o_wid] = vl[o_rhoid]*u_A*vl[o_wid] - b_A*vl[o_bzid]/o_mu0;

      FA[o_piid] = (ul[o_piid]+vl[o_piid]+0.5*(1/o_mu0)*(vl[o_bxid]*vl[o_bxid]+vl[o_byid]*vl[o_byid]+vl[o_bzid]*vl[o_bzid]))*u_A - (1/o_mu0)*b_A*(vl[o_uid]*vl[o_bxid]+vl[o_vid]*vl[o_byid]+vl[o_wid]*vl[o_bzid]);

      FA[o_bxid] = u_A*vl[o_bxid]-vl[o_uid]*b_A;

      FA[o_byid] = u_A*vl[o_byid]-vl[o_vid]*b_A;

      FA[o_bzid] = u_A*vl[o_bzid]-vl[o_wid]*b_A;

      FB[o_rhoid] = vl[o_rhoid]*u_B; 

      FB[o_uid] = vr[o_rhoid]*vr[o_uid]*u_B - vr[o_bxid]*b_B/o_mu0 + vr[o_piid]*nix[ido] + (vr[o_bxid]*vr[o_bxid]+vr[o_byid]*vr[o_byid]+vr[o_bzid]*vr[o_bzid])*nix[ido]/(2*o_mu0);

      FB[o_vid] = vr[o_rhoid]*u_B*vr[o_vid]- b_B*vr[o_byid]/o_mu0 + vr[o_piid]*niy[ido] + (vr[o_bxid]*vr[o_bxid]+vr[o_byid]*vr[o_byid]+vr[o_bzid]*vr[o_bzid])*niy[ido]/(2*o_mu0);

      FB[o_wid] = vr[o_rhoid]*u_B*vr[o_wid] - b_B*vr[o_bzid]/o_mu0;

      FB[o_piid] = (ur[o_piid]+vr[o_piid]+0.5*(1/o_mu0)*(vr[o_bxid]*vr[o_bxid]+vr[o_byid]*vr[o_byid]+vr[o_bzid]*vr[o_bzid]))*u_B - (1/o_mu0)*b_B*(vr[o_uid]*vr[o_bxid]+vr[o_vid]*vr[o_byid]+vr[o_wid]*vr[o_bzid]);

      FB[o_bxid] = u_B*vr[o_bxid]-vr[o_uid]*b_B;

      FB[o_byid] = u_B*vr[o_byid]-vr[o_vid]*b_B;

      FB[o_bzid] = u_B*vr[o_bzid]-vr[o_wid]*b_B;
 
      if (lambdaA > 0)
        for(int eq = 0; eq < o_NEQ; eq++)
          F[ido*o_NEQ+eq] = FA[eq];
      else if (lambdaB < 0)
        for(int eq = 0; eq < o_NEQ; eq++)
          F[ido*o_NEQ+eq] = FB[eq];
      else if (lambdaB >=0 && lambdaA <=0)
        for(int eq = 0; eq < o_NEQ; eq++)
          F[ido*o_NEQ+eq] = (lambdaB*FA[eq] - lambdaA*FB[eq]+lambdaA*lambdaB*(ul[eq]-ur[eq]))/(lambdaB-lambdaA);
      else
      {
        cerr << "ERROR: HLL Flux Calculation Lambda Unphysical" << endl;
        exit(-1);
      }

      //cout << CA << endl;
      //printf("j = %d, i = %d, j*(ni+1)+i=%d\n", j,i,j*(ni+1)+i);
    }
  }
/*
  int nj = F->Q[rhoid].rows();
  int ni = G->Q[rhoid].cols();
  double ul[NEQ], ur[NEQ], ub[NEQ], ut[NEQ];
  double FFLUX[NEQ];
  double GFLUX[NEQ];

  for(int j = 0; j < nj; j++)
  {
    for(int i = 0; i < ni; i++)
    {
      for(int eq = 0; eq < NEQ; eq++)
      {
        ul[eq] = U_L->Q[eq](j,i);
        ur[eq] = U_R->Q[eq](j,i);
        ub[eq] = U_B->Q[eq](j,i);
        ut[eq] = U_T->Q[eq](j,i);
      }


      computeFluxHLL(FFLUX, ul, ur, nix(j,i), niy(j,i), 0);
      computeFluxHLL(GFLUX, ub, ut, njx(j,i), njy(j,i), 1);

      //computeFluxVL(FFLUX, ul, ur, nix(j,i), niy(j,i));
      //computeFluxVL(GFLUX, ub, ut, njx(j,i), njy(j,i));

      //computeFluxRoe(FFLUX, ul, ur, nix(j,i), niy(j,i));
      //computeFluxRoe(GFLUX, ub, ut, njx(j,i), njy(j,i));

      //computeFluxHLLD(FFLUX, ul, ur, nix(j,i), niy(j,i), 0);
      //computeFluxHLLD(GFLUX, ub, ut, njx(j,i), njy(j,i), 1);



      for(int eq = 0; eq < NEQ; eq++)
      {
        F->Q[eq](j,i) = FFLUX[eq];
        G->Q[eq](j,i) = GFLUX[eq];
      }
    }
  }

  // fix right wall
  for(int j = 0; j < nj; j++)
  {
    for(int eq = 0; eq < NEQ; eq++)
    {
      ul[eq] = U_L->Q[eq](j,ni);
      ur[eq] = U_R->Q[eq](j,ni);

    }

    computeFluxHLL(FFLUX, ul, ur, nix(j,ni), niy(j,ni), 0);
    //computeFluxVL(FFLUX, ul, ur, nix(j,ni), niy(j,ni));
    //computeFluxRoe(FFLUX, ul, ur, nix(j,ni), niy(j,ni));
    //computeFluxHLLD(FFLUX, ul, ur, nix(j,ni), niy(j,ni), 0);
    for(int eq = 0; eq < NEQ; eq++)
      F->Q[eq](j,ni) = FFLUX[eq];
  }
  // fix left wall

  for(int i = 0; i < ni; i++)
  {
    for(int eq = 0; eq < NEQ; eq++)
    {
      ub[eq] = U_B->Q[eq](nj,i);
      ut[eq] = U_T->Q[eq](nj,i);

    }
    computeFluxHLL(GFLUX, ub, ut, njx(nj,i), njy(nj,i), 1);
    //computeFluxVL(GFLUX, ub, ut, njx(nj,i), njy(nj,i));
    //computeFluxRoe(GFLUX, ub, ut, njx(nj,i), njy(nj,i));
    //computeFluxHLLD(GFLUX, ub, ut, njx(nj,i), njy(nj,i), 1);
    for(int eq = 0; eq < NEQ; eq++)
      G->Q[eq](nj,i) = GFLUX[eq];
  }
*/
}
