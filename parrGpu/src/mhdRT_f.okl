@kernel void computeSourceTerm(
        double* S, 
        const double* U, 
        const double* xc, 
        const double* yc)
{
  int ig, jg;
  double thet; 
  double g=o_ACCEL;// 0.1;
  double su, sv; 
  double rho;
  for(int j = 0; j < o_njc; j++; @outer(0))
  {
    jg = j + o_ng;
    for(int i = 0; i < o_nic; i++; @inner(0))
    {
      ig = i + o_ng;
      thet = atan2(yc[j*o_nic+i], xc[j*o_nic+i]);
      rho = U[(jg*o_nic_g+ig)*o_NEQ+o_rhoid];
      su = -1*(rho)*(o_ACCEL)*cos(thet);
      sv = -1*(rho)*(o_ACCEL)*sin(thet);
      S[(j*o_nic+i)*o_NEQ+o_piid]= ((su*(-1)*g*cos(thet)) + (sv*(-1)*g*sin(thet)));
      S[(j*o_nic+i)*o_NEQ+o_uid] = su;
      S[(j*o_nic+i)*o_NEQ+o_vid] = sv;
      //cout << rho << " " << o_ACCEL  << endl;
    }
  }
}


@kernel void MUSCL(double* U_L, 
        double* U_R, 
        double* U_B, 
        double* U_T,
        const double* U)
{


  int ni = o_nic; //ncx
  int nj = o_njc;//ncy

  int ig, jg;
  double theta_L, theta_B, theta_R, theta_T;
  double denom_L, denom_B, denom_R, denom_T;
  double r_L, r_B, r_R, r_T;
  double ul, ull, ur, ut, ub, ubb, uc;
  double delta = 1.0e-6;
  double theta[2];
  double r[2];
  

  // loop over left and right
  for(int j = 0; j < nj; j++; @outer(0))
  {
    jg = j+o_ng;
    for(int i = 0; i <= ni; i++; @outer(0))
    {
      ig = i+o_ng;
      for(int eq = 0; eq < o_NEQ; eq++; @inner(0))
      {
        ul = U[(jg*o_nic_g+(ig-1))*o_NEQ+eq];
        ull = U[(jg*o_nic_g+(ig-2))*o_NEQ+eq];
        ur = U[(jg*o_nic_g+(ig+1))*o_NEQ+eq];
        uc = U[(jg*o_nic_g+ig)*o_NEQ+eq];

        denom_L = uc - ul;
        denom_R = ur - ul;        
        denom_L = copysign(1.0,denom_L)*fmax(delta, fabs(denom_L));    
        denom_R = copysign(1.0,denom_R)*fmax(delta, fabs(denom_R));    

        r[0] = (ul - ull)/denom_L;
        r[1] = (uc - ul)/denom_R;
        switch (o_limiter)
        {
          case 1:
            for(int id = 0; id < 2; id++)
              theta[id] = 1.0;
          case 2:
            for(int id = 0; id < 2; id++)
              theta[id] = (r[id]+fabs(r[id]))/(1.0+fabs(r[id]));
          case 3:
            for(int id = 0; id < 2; id++)
              theta[id] = (r[id]+r[id]*r[id])/(1.0+r[id]*r[id]);
          case 4:
            for(int id = 0; id < 2; id++)
              theta[id] = 1.5*(r[id]*r[id] + r[id]) / (1.0 + r[id] + r[id]*r[id]);
          case 5:
            for(int id = 0; id < 2; id++)
              theta[id] = fmax(0.0,fmin(2.0*r[id],fmin(0.5*(1.0+r[id]),2.0)));
          case 6:
            for(int id = 0; id < 2; id++)
              theta[id] = fmax(0.0,fmin(1.0,r[id]));
          case 7:
            for(int id = 0; id < 2; id++)
              theta[id] = fmax(0.0,fmax(fmin(2.0*r[id],1),fmin(r[id],2.0)));
        }

        theta_L=theta[0];
        theta_R=theta[1];

        int fill = (j*(ni+1)+i)*o_NEQ+eq;

        U_R[fill] = uc - 0.5*theta_R*(ur - uc);
        U_L[fill] = ul + 0.5*theta_L*(uc - ul);

      }
    }
  }

  // loop over bot and top
  for(int j = 0; j <= nj; j++; @outer(1))
  {
    jg = j+o_ng;
    for(int i = 0; i < ni; i++; @outer(1))
    {
      ig = i+o_ng;
      for(int eq = 0; eq < o_NEQ; eq++; @inner(1))
      {
        uc = U[(jg*o_nic_g+ig)*o_NEQ+eq];
        ub = U[((jg-1)*o_nic_g+ig)*o_NEQ+eq];
        ubb = U[((jg-2)*o_nic_g+ig)*o_NEQ+eq];
        ut = U[((jg+1)*o_nic_g+ig)*o_NEQ+eq];

        denom_B = uc - ub;
        denom_T = ut - ub;
        denom_B = copysign(1.0,denom_B)*fmax(delta, fabs(denom_B));    
        denom_T = copysign(1.0,denom_T)*fmax(delta, fabs(denom_T));    

        r[0] = (ub - ubb)/denom_B;
        r[1] = (uc - ub)/denom_T;
        switch (o_limiter)
        {
          case 1:
            for(int id = 0; id < 2; id++)
              theta[id] = 1.0;
          case 2:
            for(int id = 0; id < 2; id++)
              theta[id] = (r[id]+fabs(r[id]))/(1.0+fabs(r[id]));
          case 3:
            for(int id = 0; id < 2; id++)
              theta[id] = (r[id]+r[id]*r[id])/(1.0+r[id]*r[id]);
          case 4:
            for(int id = 0; id < 2; id++)
              theta[id] = 1.5*(r[id]*r[id] + r[id]) / (1.0 + r[id] + r[id]*r[id]);
          case 5:
            for(int id = 0; id < 2; id++)
              theta[id] = fmax(0.0,fmin(2.0*r[id],fmin(0.5*(1.0+r[id]),2.0)));
          case 6:
            for(int id = 0; id < 2; id++)
              theta[id] = fmax(0.0,fmin(1.0,r[id]));
          case 7:
            for(int id = 0; id < 2; id++)
              theta[id] = fmax(0.0,fmax(fmin(2.0*r[id],1),fmin(r[id],2.0)));
        }

        theta_B=theta[0];
        theta_T=theta[1];

        int fill = (j*ni+i)*o_NEQ+eq;

        U_B[fill] = ub + 0.5*theta_B*(uc - ub);
        U_T[fill] = uc - 0.5*theta_T*(ut - uc);

        /*
        if(eq==0){
            printf("c = %d, b = %d, t = %d, fill = %d\n", 
                (jg*o_nic_g+ig), 
                ((jg-1)*o_nic_g+ig), 
                ((jg+1)*o_nic_g+ig),(j*(ni)+i));

            printf("c = %lf, b = %lf, t = %lf, U_B=%lf, U_T=%lf\n", 
                uc, ub, ut, U_B[fill], U_T[fill]);
        }
        */
      }
    }
  }
}

@kernel void compute2dFlux(double* F, 
        double* G,  
        const double* U_L,  
        const double* U_R,  
        const double* U_B,  
        const double* U_T, 
        const double* njx, 
        const double* njy, 
        const double* nix, 
        const double* niy)
{
  int nj = o_njc;
  int ni = o_nic;
  double ul[NEQ], ur[NEQ], ub[NEQ], ut[NEQ];
  double FFLUX[NEQ];
  double GFLUX[NEQ];
  for(int j = 0; j < nj; j++; @outer(0))
  {
    for(int i = 0; i < ni; i++; @outer(0))


  }
/*
  int nj = F->Q[rhoid].rows();
  int ni = G->Q[rhoid].cols();
  double ul[NEQ], ur[NEQ], ub[NEQ], ut[NEQ];
  double FFLUX[NEQ];
  double GFLUX[NEQ];

  for(int j = 0; j < nj; j++)
  {
    for(int i = 0; i < ni; i++)
    {
      for(int eq = 0; eq < NEQ; eq++)
      {
        ul[eq] = U_L->Q[eq](j,i);
        ur[eq] = U_R->Q[eq](j,i);
        ub[eq] = U_B->Q[eq](j,i);
        ut[eq] = U_T->Q[eq](j,i);
      }

      computeFluxHLL(FFLUX, ul, ur, nix(j,i), niy(j,i), 0);
      computeFluxHLL(GFLUX, ub, ut, njx(j,i), njy(j,i), 1);

      //computeFluxVL(FFLUX, ul, ur, nix(j,i), niy(j,i));
      //computeFluxVL(GFLUX, ub, ut, njx(j,i), njy(j,i));

      //computeFluxRoe(FFLUX, ul, ur, nix(j,i), niy(j,i));
      //computeFluxRoe(GFLUX, ub, ut, njx(j,i), njy(j,i));

      //computeFluxHLLD(FFLUX, ul, ur, nix(j,i), niy(j,i), 0);
      //computeFluxHLLD(GFLUX, ub, ut, njx(j,i), njy(j,i), 1);



      for(int eq = 0; eq < NEQ; eq++)
      {
        F->Q[eq](j,i) = FFLUX[eq];
        G->Q[eq](j,i) = GFLUX[eq];
      }
    }
  }

  // fix right wall
  for(int j = 0; j < nj; j++)
  {
    for(int eq = 0; eq < NEQ; eq++)
    {
      ul[eq] = U_L->Q[eq](j,ni);
      ur[eq] = U_R->Q[eq](j,ni);

    }

    computeFluxHLL(FFLUX, ul, ur, nix(j,ni), niy(j,ni), 0);
    //computeFluxVL(FFLUX, ul, ur, nix(j,ni), niy(j,ni));
    //computeFluxRoe(FFLUX, ul, ur, nix(j,ni), niy(j,ni));
    //computeFluxHLLD(FFLUX, ul, ur, nix(j,ni), niy(j,ni), 0);
    for(int eq = 0; eq < NEQ; eq++)
      F->Q[eq](j,ni) = FFLUX[eq];
  }
  // fix left wall

  for(int i = 0; i < ni; i++)
  {
    for(int eq = 0; eq < NEQ; eq++)
    {
      ub[eq] = U_B->Q[eq](nj,i);
      ut[eq] = U_T->Q[eq](nj,i);

    }
    computeFluxHLL(GFLUX, ub, ut, njx(nj,i), njy(nj,i), 1);
    //computeFluxVL(GFLUX, ub, ut, njx(nj,i), njy(nj,i));
    //computeFluxRoe(GFLUX, ub, ut, njx(nj,i), njy(nj,i));
    //computeFluxHLLD(GFLUX, ub, ut, njx(nj,i), njy(nj,i), 1);
    for(int eq = 0; eq < NEQ; eq++)
      G->Q[eq](nj,i) = GFLUX[eq];
  }
*/
}


